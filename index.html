<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"stonecj.cn","root":"/","images":"/images","scheme":"Muse","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="shield‘s blog">
<meta property="og:url" content="http://stonecj.cn/index.html">
<meta property="og:site_name" content="shield‘s blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="shield">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://stonecj.cn/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>
<title>shield‘s blog</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">shield‘s blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
        <li class="menu-item menu-item-schedule"><a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">shield</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/just-a-stone" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;just-a-stone" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://stonecj.cn/2021/03/05/kafka%E6%95%85%E9%9A%9C-partition%20offline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shield">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shield‘s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/05/kafka%E6%95%85%E9%9A%9C-partition%20offline/" class="post-title-link" itemprop="url">kafka故障-partition offline</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-03-05 14:31:00 / Modified: 16:40:57" itemprop="dateCreated datePublished" datetime="2021-03-05T14:31:00+08:00">2021-03-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>producer发送消息超时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2021-03-05 10:06:47.083 [pool-5-thread-3] ERROR com.alibaba.otter.canal.kafka.CanalKafkaProducer - java.util.concurrent.ExecutionException: org.apache.kafka.common.errors.TimeoutException: Expiring 1 record(s) for boss-clearing.clear_task_execute_record-0: 30094 ms has passed since batch creation plus linger time</span><br><span class="line">java.lang.RuntimeException: java.util.concurrent.ExecutionException: org.apache.kafka.common.errors.TimeoutException: Expiring 1 record(s) for boss-clearing.clear_task_execute_record-0: 30094 ms has passed since batch creation plus linger time</span><br><span class="line">	at com.alibaba.otter.canal.kafka.CanalKafkaProducer.produce(CanalKafkaProducer.java:215) ~[canal.server-1.1.4.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.kafka.CanalKafkaProducer.send(CanalKafkaProducer.java:179) ~[canal.server-1.1.4.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.kafka.CanalKafkaProducer.send(CanalKafkaProducer.java:117) ~[canal.server-1.1.4.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.server.CanalMQStarter.worker(CanalMQStarter.java:183) [canal.server-1.1.4.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.server.CanalMQStarter.access$500(CanalMQStarter.java:23) [canal.server-1.1.4.jar:na]</span><br><span class="line">	at com.alibaba.otter.canal.server.CanalMQStarter$CanalMQRunnable.run(CanalMQStarter.java:225) [canal.server-1.1.4.jar:na]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_161]</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_161]</span><br><span class="line">	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_161]</span><br></pre></td></tr></table></figure>

<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ol>
<li>网络连接问题，导致超时</li>
<li>kafka故障</li>
</ol>
<blockquote>
<p>通过查看kafka服务状态，确认是kafka问题<br>同时，服务状态显示，<code>400+ partition offline</code></p>
</blockquote>
<p>到这里，可以肯定kafka集群出了故障。<br>但是，按理说，kafka是分布式服务。topic分partition，partition又有replica。单个broker故障，数据完整性不会受影响。replica的数据完全能顶上。</p>
<hr>
<h2 id="服务状态查看"><a href="#服务状态查看" class="headerlink" title="服务状态查看"></a>服务状态查看</h2><p><img src="https://private-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/20210305150715.png"></p>
<p>从网页看，发现<code>under replicated partition</code>，即分区在复制中。</p>
<p>下面，我们具体看看topic分区情况<br><code>./kafka-topics.sh --describe --zookeeper xx-xx-01:2181   --under-replicated-partitions</code><br><img src="https://private-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/20210305152651.png"></p>
<p>示意：ISR即 in-sync replica<br>假设，有数据Topic: __consumer_offsets       Partition: 6    Leader: 146     Replicas: 222,146,225   Isr: 146,222<br>数据一共3份，但是同步中的只有2份。可知broker 225故障。</p>
<p>此处，我通过重启225的kafka服务恢复。</p>
<h2 id="为什么一个备份故障，服务就不可用"><a href="#为什么一个备份故障，服务就不可用" class="headerlink" title="为什么一个备份故障，服务就不可用"></a>为什么一个备份故障，服务就不可用</h2><p>kafka topic有参数acks，可选值0,1,2….all<br>意思是，几个副本保存成功，认为ack成功</p>
<p>当broker故障，topic isr数量变少。可能存在一种情况: 同步中的副本数 &lt; 提交成功需要的副本数</p>
<p>GG</p>
<hr>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fxjwind/p/4972244.html">Apche Kafka 的生与死 – failover 机制详解</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://stonecj.cn/2020/04/20/%E8%AF%84%E5%88%86%E5%8D%A1-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E8%BD%AC%E8%AF%84%E5%88%86%E5%8D%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shield">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shield‘s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/04/20/%E8%AF%84%E5%88%86%E5%8D%A1-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E8%BD%AC%E8%AF%84%E5%88%86%E5%8D%A1/" class="post-title-link" itemprop="url">评分卡-逻辑回归转评分卡</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2020-04-20 10:19:47" itemprop="dateCreated datePublished" datetime="2020-04-20T10:19:47+08:00">2020-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2021-03-05 18:42:05" itemprop="dateModified" datetime="2021-03-05T18:42:05+08:00">2021-03-05</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>此评分卡非彼评分卡</p>
<p>以逻辑回归跑出逾期概率</p>
<p>概率值转评分</p>
</blockquote>
<p>参考文献：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://stonecj.cn/2019/12/16/java-process-consume-more-memory-than-Xmx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shield">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shield‘s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/16/java-process-consume-more-memory-than-Xmx/" class="post-title-link" itemprop="url">java process consume more memory than Xmx</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2019-12-16 13:50:35 / Modified: 14:55:48" itemprop="dateCreated datePublished" datetime="2019-12-16T13:50:35+08:00">2019-12-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>java应用程序启动时，我们常常会加上 <code>-Xmx</code> 选项，以确保进程不会吃掉我们限制的范围。</p>
<p>然后你可能收到这样的惊喜。当打开命令行工具，查看 <code>top</code> 信息。会发现应用吃掉的内存[resident memory usage(RES)]超过了我们的预设。</p>
</blockquote>
<p>为什么进程消耗的内存超过了我们分配？是bug还是完全正常的现象？</p>
<p>首先，一部分原因可能是代码造成的内存泄漏。但是，99%的情况下，都是jvm的正常行为。因为 <code>-Xmx</code> 仅仅是限制了应用程序的堆大小。</p>
<p>除了堆，这里还有其他几个内存空间被应用程序使用，比如 <code>permgen</code> 、<code>stack</code> 。为了限制它们，我们需要额外指定几个参数 <code>-XX:MaxPermSize</code> 、<code>-Xss</code> 。</p>
<p>简而言之，我们可以通过如下公式，预测我们应用的内存占用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Max memory = [-Xmx] + [-XX:MaxPermSize] + number_of_threads * [-Xss]</span><br></pre></td></tr></table></figure>



<p>但是，除应用外。jvm本身也要消耗内存：</p>
<ul>
<li>垃圾收集<ul>
<li>java是一门自动垃圾回收语言，自动回收程序跟踪对象，执行回收需要占用内存</li>
<li>G1更是出了名的倾向于过多占用内存</li>
</ul>
</li>
<li>即时编译（JIT）<ul>
<li>虚拟机为了提升代码执行效率</li>
<li>需要跟踪代码执行</li>
</ul>
</li>
<li>堆外内存<ul>
<li>使用直接或映射的 ByteBuffers 或者三方工具。在无意中拓展了堆空间，这些空间不被java虚拟机控制</li>
</ul>
</li>
<li>本地接口（JNI）<ul>
<li>使用本地代码，就要占用本地内存</li>
</ul>
</li>
<li>元空间（Metaspace）<ul>
<li>java8中新增的空间，取代永久代保存类定义信息。</li>
</ul>
</li>
</ul>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://stonecj.cn/2019/12/04/zookeeper%E9%9B%86%E7%BE%A4oom%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shield">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shield‘s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/12/04/zookeeper%E9%9B%86%E7%BE%A4oom%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">zookeeper集群oom记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-12-04 18:58:07" itemprop="dateCreated datePublished" datetime="2019-12-04T18:58:07+08:00">2019-12-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2019-12-05 16:25:34" itemprop="dateModified" datetime="2019-12-05T16:25:34+08:00">2019-12-05</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>cloudera集群邮件告警，zookeeper server离线。</p>
<p>第一次处理，无脑重启集群。因为白天没什么任务，直接重启可以解决部分资源紧张问题。</p>
<p>第一次处理结果，失败。</p>
<h3 id="原因复查"><a href="#原因复查" class="headerlink" title="原因复查"></a>原因复查</h3><p>重启不能解决，那么就是真的有问题了。</p>
<p>首先，我们检查了集群角色日志，发现out of memory错误。</p>
<p>显然应用内存爆了……</p>
<hr>
<p>第二次处理，在Cloudera manager中修改zookeeper配置，添加内存到2G。</p>
<p>第二次处理结果，失败。</p>
<p>内存从1G调整到2G，直接double，没道理再崩啊 0-0</p>
<h3 id="dump分析"><a href="#dump分析" class="headerlink" title="dump分析"></a>dump分析</h3><p>没办法，拉出zk服务的oom时的堆转储文件</p>
<p>可以看到，起初的dump文件800+M；后来的dump文件1.6+G</p>
<p>神奇，挂的很完美</p>
<hr>
<p><img src="https://private-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/20191204214118.png"></p>
<p>在序列化当前事务时出错。</p>
<hr>
<p>通过java visual vm查看，数组扩容时出错。跟进去看</p>
<p><img src="https://private-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/20191204214422.png"></p>
<hr>
<p>输出流写出大量数据，导致数组扩容。申请不到足够内存。</p>
<p>那么问题来了，zk上，通过只会存储极少量注册信息。怎么会有这么多数据。</p>
<h3 id="zk数据检查"><a href="#zk数据检查" class="headerlink" title="zk数据检查"></a>zk数据检查</h3><p>zk服务已经宕机，我们无法通过寻常方式检查zk节点信息。</p>
<p>如此，我们想到zk数据存储在哪里呢？</p>
<p>答案是：datadir指定的目录，配置在zoo.cfg中</p>
<hr>
<p>我们观察到，数据目录下，同时有zk日志文件、快照文件。</p>
<p>可以看到，快照文件大小，无比接近dump文件。进一步确认数据量爆炸。</p>
<p>快照文件查看方式如下，</p>
<p><code>java -cp /opt/cloudera/parcels/CDH-6.0.0-1.cdh6.0.0.p0.537114/lib/zookeeper/lib/log4j.jar:/opt/cloudera/parcels/CDH-6.0.0-1.cdh6.0.0.p0.537114/lib/zookeeper/build/*:/opt/cloudera/parcels/CDH-6.0.0-1.cdh6.0.0.p0.537114/lib/zookeeper/build/lib/*:/opt/cloudera/parcels/CDH-6.0.0-1.cdh6.0.0.p0.537114/lib/zookeeper/*:/opt/cloudera/parcels/CDH-6.0.0-1.cdh6.0.0.p0.537114/lib/zookeeper/lib/*:/opt/cloudera/cm/lib/plugins/event-publish-6.0.0-shaded.jar:/opt/cloudera/cm/lib/plugins/tt-instrumentation-6.0.0.jar org.apache.zookeeper.server.SnapshotFormatter snapshot.3000540f8 | more</code></p>
<p>配合grep/awk/sort等，我们发现，集群上有近10000个数据节点。</p>
<p>其中有部分节点比较大，达到0.3M。</p>
<p>进一步观察，较大的这些文件，都是hive share lock。</p>
<hr>
<p>集群中一直有hive在运行，但是从没发现hive使用了如此多的zk资源。属实意外！！！</p>
<h3 id="hive事务实现"><a href="#hive事务实现" class="headerlink" title="hive事务实现"></a>hive事务实现</h3><p>穿插一点hive：hive事务由共享锁、排它锁实现。在我锁使用的版本中，锁被保存的zk。</p>
<hr>
<p>询问可能使用hive的同事，事发时间确实有跑脚本。</p>
<hr>
<p>那么问题基本定位，gps位置信息在hive中分区存储，拥有大量分区表。</p>
<p>同事的sql使用了这些分区表，所以zk中写入了大量hive共享锁信息（估计近4000）</p>
<h3 id="zk重启"><a href="#zk重启" class="headerlink" title="zk重启"></a>zk重启</h3><p>调大zk内存到5G，重启</p>
<p>可以看到follower从leader同步快照文件。由于文件较大，同步慢慢不结束。</p>
<hr>
<p>这里方法有点暴力，生产不建议操作</p>
<p>强制重新初始化zk数据目录<code>zookeeper-server-init</code>，重启zk</p>
<h3 id="最后的处理"><a href="#最后的处理" class="headerlink" title="最后的处理"></a>最后的处理</h3><p>关闭hive事务（当前业务上刚好没用到该特性）</p>
<p>重启所有服务</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://stonecj.cn/2019/11/17/%E9%87%8D%E8%AF%BBHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shield">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shield‘s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/11/17/%E9%87%8D%E8%AF%BBHashMap/" class="post-title-link" itemprop="url">重读HashMap</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-11-17 17:37:12" itemprop="dateCreated datePublished" datetime="2019-11-17T17:37:12+08:00">2019-11-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2019-11-26 23:30:37" itemprop="dateModified" datetime="2019-11-26T23:30:37+08:00">2019-11-26</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>精简篇幅，本篇暂不讨论为java stream服务的特性</p>
</blockquote>
<h3 id="1-Interfaces"><a href="#1-Interfaces" class="headerlink" title="1. Interfaces"></a>1. Interfaces</h3><ul>
<li>Map&lt;K,V&gt;</li>
<li>Cloneable</li>
<li>Serializable</li>
</ul>
<h3 id="2-Abstract-super-class"><a href="#2-Abstract-super-class" class="headerlink" title="2. Abstract super class"></a>2. Abstract super class</h3><ul>
<li>AbstractMap&lt;K,V&gt;</li>
</ul>
<p><img src="https://private-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/20191124194353.png"></p>
<h3 id="3-Static-fields"><a href="#3-Static-fields" class="headerlink" title="3. Static fields"></a>3. Static fields</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment">	   */</span></span><br><span class="line"><span class="comment">// 初始化容量, 默认16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">		 * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">		 * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"><span class="comment">// 最大容量，默认最大int</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line"><span class="comment">// 负载因子，触发resize的阀值，默认0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment">     * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment">     * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment">     * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment">     * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment">     * shrinkage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 链表转红黑树的阀值（防止hash碰撞过于严重）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment">     * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment">     * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 红黑树转链表的阀值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">     * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 转红黑树的前提阀值（先扩容table，再扩容bin）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://private-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/20191125155237.png"></p>
<h3 id="4-class-fields"><a href="#4-class-fields" class="headerlink" title="4. class fields"></a>4. class fields</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">     * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">     * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">     * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// hashMap数据存储的地方</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment">     * for keySet() and values().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// hashMap数据访问对象(视图/缓存实例)，依赖HashIterator实现entry访问</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// map元素数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment">     * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment">     * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment">     * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment">     * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// map修改次数，包括put\remove</span></span><br><span class="line"><span class="comment">// 在迭代map数据前后，做双重检查。并发访问，抛出运行时异常</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line">    <span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line">    <span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line">    <span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="comment">// 下次扩容阀值</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The load factor for the hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 扩容因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Each of these fields are initialized to contain an instance of the</span></span><br><span class="line"><span class="comment">     * appropriate view the first time this view is requested.  The views are</span></span><br><span class="line"><span class="comment">     * stateless, so there&#x27;s no reason to create more than one of each.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Since there is no synchronization performed while accessing these fields,</span></span><br><span class="line"><span class="comment">     * it is expected that java.util.Map view classes using these fields have</span></span><br><span class="line"><span class="comment">     * no non-final fields (or any fields at all except for outer-this). Adhering</span></span><br><span class="line"><span class="comment">     * to this rule would make the races on these fields benign.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;It is also imperative that implementations read the field only once,</span></span><br><span class="line"><span class="comment">     * as in:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt; &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * public Set&lt;K&gt; keySet() &#123;</span></span><br><span class="line"><span class="comment">     *   Set&lt;K&gt; ks = keySet;  // single racy read</span></span><br><span class="line"><span class="comment">     *   if (ks == null) &#123;</span></span><br><span class="line"><span class="comment">     *     ks = new KeySet();</span></span><br><span class="line"><span class="comment">     *     keySet = ks;</span></span><br><span class="line"><span class="comment">     *   &#125;</span></span><br><span class="line"><span class="comment">     *   return ks;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     *&#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">// 类似entrySet的key访问对象</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;K&gt;        keySet;</span><br><span class="line"><span class="comment">// 类似entrySet的value访问对象</span></span><br><span class="line"><span class="keyword">transient</span> Collection&lt;V&gt; values;</span><br></pre></td></tr></table></figure>



<h3 id="5-Inner-classes"><a href="#5-Inner-classes" class="headerlink" title="5. Inner classes"></a>5. Inner classes</h3><p><img src="https://private-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/20191124234735.png"></p>
<h4 id="5-1简单存储对象"><a href="#5-1简单存储对象" class="headerlink" title="5.1简单存储对象"></a>5.1简单存储对象</h4><p>simpleEntry：键值对存储对象。</p>
<p>simpleImmutableEntry：不支持修改的键值对存储对象。</p>
<p>共性：都重写了equal方法，比较key &amp; value</p>
<h4 id="5-2-hash与红黑树"><a href="#5-2-hash与红黑树" class="headerlink" title="5.2 hash与红黑树"></a>5.2 hash与红黑树</h4><p>e g:</p>
<ul>
<li>hash散列作用</li>
<li>hash算法选择</li>
<li>hash算法不可控因素</li>
<li>数组与红黑树转换条件、原因</li>
<li>红黑树机制简单介绍</li>
</ul>
<h5 id="5-2-1-什么是hash算法"><a href="#5-2-1-什么是hash算法" class="headerlink" title="5.2.1 什么是hash算法"></a>5.2.1 什么是hash算法</h5><blockquote>
<p>又称散列算法，是一种从任意文件中创造小的数字「指纹」的方法。</p>
<p>与指纹一样，散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。</p>
</blockquote>
<p><em>特点：</em></p>
<ul>
<li>正向快速</li>
<li>逆向困难</li>
<li>输入敏感</li>
<li>冲突避免：很难找到两段内容不同的明文，使得它们的 hash 值一致（发生冲突）。</li>
</ul>
<p>常见实现方式：取模/异或/位运算</p>
<p>下面给出在Java中几个常用的哈希码(hashCode)的算法。</p>
<ol>
<li>Object类的hashCode. 返回对象的经过处理后的内存地址，由于每个对象的内存地址都不一样，所以哈希码也不一样。这个是native方法，取决于JVM的内部设计，一般是某种C地址的偏移。</li>
<li>String类的hashCode. 根据String类包含的字符串的内容，根据一种特殊算法返回哈希码，只要字符串的内容相同，返回的哈希码也相同。</li>
<li>Integer等包装类，返回的哈希码就是Integer对象里所包含的那个整数的数值，例如Integer i1=new Integer(100), i1.hashCode的值就是100 。由此可见，2个一样大小的Integer对象，返回的哈希码也一样。</li>
<li>int，char这样的基础类，它们不需要hashCode，如果需要存储时，将进行自动装箱操作，计算方法同上。</li>
</ol>
<h5 id="5-2-2-散列"><a href="#5-2-2-散列" class="headerlink" title="5.2.2 散列"></a>5.2.2 散列</h5><p><code>return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code></p>
<p>取hashcode参与运算，因为hashcode返回值为int（32位）</p>
<p>所以，将hashcode右移16位，再做异或运算，混合了高低位信息。</p>
<h5 id="5-2-3-从hash到index"><a href="#5-2-3-从hash到index" class="headerlink" title="5.2.3 从hash到index"></a>5.2.3 从hash到index</h5><p><code>i = (tab.length - 1) &amp; hash；</code></p>
<p>与运算 – 取一个数中指定位</p>
<p>index取值范围[0, tab.lenth -1] </p>
<p>与运算后，即为对应index。</p>
<p><strong>从上文 [从hash到index](#####5.2.3 从hash到index)可以发现，在寻找map元素位置过程中，使用了与运算取hash结果中指定位。结合map容量字段定义，可以发现，容量为2的指数倍，才能刚好取hash结果中指定位。另一个可得结果是，map的数组大小，不会超过2的16次方。</strong></p>
<h5 id="5-2-4-hash碰撞"><a href="#5-2-4-hash碰撞" class="headerlink" title="5.2.4 hash碰撞"></a>5.2.4 hash碰撞</h5><p>散列算法分布均为，也无法控制输入的数据分布。所以碰撞时必然的，甚至分布十分集中。</p>
<p>数组中存储 <code>Node</code> 对象。</p>
<p>当该index中对象碰撞较少时，以链表存储。新node放置在最前面。</p>
<p>当该index中对象碰撞较多时，链表转换为红黑树<code>TreeNode</code>。红黑树高度为log n，所以其查找、插入、删除操作复杂度均为O(log N)。</p>
<h5 id="5-2-5-红黑树介绍（省略……哈哈）"><a href="#5-2-5-红黑树介绍（省略……哈哈）" class="headerlink" title="5.2.5 红黑树介绍（省略……哈哈）"></a>5.2.5 红黑树介绍（省略……哈哈）</h5><h4 id="5-3-并行处理API（忽略）"><a href="#5-3-并行处理API（忽略）" class="headerlink" title="5.3 并行处理API（忽略）"></a>5.3 并行处理API（忽略）</h4><h4 id="5-4-map数据访问对象"><a href="#5-4-map数据访问对象" class="headerlink" title="5.4 map数据访问对象"></a>5.4 map数据访问对象</h4><ul>
<li>entrySet</li>
<li>keySet</li>
<li>valueSet</li>
</ul>
<p>隐藏了底层复杂的数据结构（数组、链表、红黑树）。简化数据遍历。</p>
<p>实例化的内部类，持有hashmap的字段信息。同时自身也会被作为hashmap中字段存储，可视为map的视图。</p>
<h5 id="5-4-1-map数据遍历与删除对象"><a href="#5-4-1-map数据遍历与删除对象" class="headerlink" title="5.4.1 map数据遍历与删除对象"></a>5.4.1 map数据遍历与删除对象</h5><p>set对象内部封装了迭代器，允许在迭代器中遍历、删除对象。</p>
<p><code>iterator</code> 保存了当前<code>Node</code> 和下一个<code>Node</code> 。如果此时其他线程修改了map结构（增加删除key），那么下一个<code>Node</code>可能就不再存在，或者变成别的。</p>
<p><strong>fast-fail</strong></p>
<p>hashmap是不允许并发操作的（get除外）</p>
<ul>
<li>并发put/remove<ul>
<li>hash碰撞时，链表新元素插入头部。先put的可能消失</li>
<li>hash碰撞时，红黑树同上（根结点会被替换）</li>
</ul>
</li>
<li>并发(put/remove) 和 iterator<ul>
<li>每次key发生变化，modCount就会+1。iterator每次next后，都会检查next操作后modCount与iterator保存的expectedModCount是否一致。一旦不一致，就会抛出<code>ConcurrentModificationException</code>。</li>
</ul>
</li>
</ul>
<p>Ps: fast-fail可以作为一个代码bug的提示。hashmap普通的修改操作不支持并发，可能会丢数据（扩容问题cover later）。iterator操作时，完全不允许key发生变更，故一旦发现操作数发生变化，抛出异常。</p>
<h3 id="6-扩容过程-amp-并发扩容问题"><a href="#6-扩容过程-amp-并发扩容问题" class="headerlink" title="6. 扩容过程&amp;并发扩容问题"></a>6. 扩容过程&amp;并发扩容问题</h3><p>死循环</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linghu-java/p/10598758.html">为什么Map桶中个数超过8才转为红黑树</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5a66a08d5188253dc3321da0">hashmap扩容死循环</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://stonecj.cn/2019/10/27/LRU%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shield">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shield‘s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/10/27/LRU%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/" class="post-title-link" itemprop="url">LRU及其变体</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2019-10-27 15:17:44 / Modified: 19:00:49" itemprop="dateCreated datePublished" datetime="2019-10-27T15:17:44+08:00">2019-10-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="什么是LRU"><a href="#什么是LRU" class="headerlink" title="什么是LRU"></a>什么是LRU</h3><p>​        LRU: Least Recent Used。意即：最近最少使用。写代码好几年，我一直这么以为的。</p>
<p>​        重读wiki，我觉着当初这个名字，起的真不怎么样。具体实现中，实际上要淘汰的是，当前最久未被访问数据。如果一定要换个名字，我觉着 “最近最久未被访问” 策略更合适。</p>
<p>###基本实现</p>
<p>统计最长未被访问，一般有两种方式。</p>
<ol>
<li>记录上次访问时间（淘汰掉，访问时间最早的）</li>
<li>记录上次访问后，访问了多少次其他缓存（淘汰掉未被访问次数最多的）</li>
</ol>
<p>​        wiki基准实现描述的上述第二种方式。以node对象为载体，记录。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String key;</span><br><span class="line">  <span class="keyword">private</span> Object value;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> unAccessCount;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    unAccessCount = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 其他node unAccessCount++</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        当缓存空间占满，需要淘汰内存页时，选择unAccessCount最大的节点，丢弃之。</p>
<p>​        对应操作系统虚拟内存来说，如果node是具体内存页，那么我们还需要一个内存表来辅助查询。例如，添加一个map，处理key与node的引用。加速key的检索过程。</p>
<p>缺陷：</p>
<ul>
<li>每次访问一个随机key A，其他所有key需要加 1</li>
</ul>
<h3 id="LRU变体"><a href="#LRU变体" class="headerlink" title="LRU变体"></a>LRU变体</h3><h4 id="1-变体-基准实现的优化"><a href="#1-变体-基准实现的优化" class="headerlink" title="1. 变体 - 基准实现的优化"></a>1. 变体 - 基准实现的优化</h4><p>​        使用一个固定长度的双向链表存储node。A端为最新访问数据，B端为最久未访问数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LruCache</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前最新插入或访问的缓存</span></span><br><span class="line">  <span class="keyword">private</span> Node first;</span><br><span class="line">  <span class="comment">// 需要时，被过期的缓存</span></span><br><span class="line">  <span class="keyword">private</span> Node last;</span><br><span class="line">  <span class="comment">// 缓存容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> capitalSize;</span><br><span class="line">  <span class="comment">// 存储缓存数据(双向链表) -- 增删快</span></span><br><span class="line">  <span class="keyword">private</span> Node nodes;</span><br><span class="line">  <span class="comment">// 提供缓存命中查询 -- 查询快</span></span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, Node&gt; cache;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> value <span class="title">get</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">    Object value = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">      removeNode(key);</span><br><span class="line">      addFirstNode(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span></span>&#123;</span><br><span class="line">    Object oldValue = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (oldValue != <span class="keyword">null</span>)&#123;</span><br><span class="line">      removeNode(key);</span><br><span class="line">      addFirstNode(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cache.size() &gt;= capitalSize)&#123;</span><br><span class="line">      removeLastNode();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> vlid <span class="title">addFirstNode</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(String key)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeLastNode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>优点：</p>
<ul>
<li>相较基础版每次修改accessCount，操作数明显降低</li>
</ul>
<p>缺点：</p>
<ul>
<li>与基础版相同，最近访问一次，就会被当作热点数据（<strong>LRU均存在该问题</strong>）</li>
</ul>
<h4 id="2-变体-redis方案"><a href="#2-变体-redis方案" class="headerlink" title="2. 变体 - redis方案"></a>2. 变体 - redis方案</h4><p>​        redis自带过期机制，所以，其LRU实现是基于时间的。</p>
<p>早期方案：</p>
<p>​        缓存容量满时，redis基于 <code>server.maxmemory_samples</code> 随机抽取指定数量的key，过期其中访问时间最早的。</p>
<p>优点：</p>
<ul>
<li>过期操作快</li>
</ul>
<p>缺点：</p>
<ul>
<li>过期key随机性较大，刚存入的数据，也可能被抽中</li>
</ul>
<p>改进方案：</p>
<p>​        创建一个指定容量的等待过期队列。</p>
<p>​        第一步，随机抽取一个key，置入队列；第二步，随机抽取指定个数key，将访问时间小于池中最小访问时间的key置入队列。</p>
<p>​        缓存容量不足时，过期队列中访问时间最早的key。</p>
<p>优点：</p>
<ul>
<li>异步维护待过期队列</li>
<li>过期操作快</li>
</ul>
<h5 id="redis为什么要自定义过期策略"><a href="#redis为什么要自定义过期策略" class="headerlink" title="redis为什么要自定义过期策略"></a>redis为什么要自定义过期策略</h5><ul>
<li>redis key数量不固定。如果key数量过多，选择全局最久未访问key耗时高</li>
<li>redis为单线程应用，不允许过期策略过度消耗</li>
<li>redis本身存在过期策略。配置容器满适用LRU时，需要与LRU策略兼容</li>
</ul>
<h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>​        Least-frequently used：最小访问频次，频次最低的会被过期。与LRU相似。</p>
<p>​        记录访问次数，存活时间，可得。</p>
<h3 id="PLRU（CPU缓存过期策略）"><a href="#PLRU（CPU缓存过期策略）" class="headerlink" title="PLRU（CPU缓存过期策略）"></a>PLRU（CPU缓存过期策略）</h3><p>​        <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pseudo-LRU">Pseudo-LRU</a>：伪 - LRU。适用于cpu这样的多级缓存系统。</p>
<p>​        CPU缓存系统，每一级维护LRU策略成本过高；所以，CPU设计者们，采用了近似的LRU算法。例如：L1层级区块L1a，对应L2层级L2a、L2b两个区块，则针对L1a每次过期L2a、L2b两个区块中的一个（而不是针对整个L2层过期最近最久未访问）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://stonecj.cn/2019/09/02/%E5%89%96%E6%9E%90disruptor-writing-to-the-ring-buffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shield">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shield‘s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/09/02/%E5%89%96%E6%9E%90disruptor-writing-to-the-ring-buffer/" class="post-title-link" itemprop="url">剖析disruptor: writing to the ring buffer</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-09-02 16:29:52" itemprop="dateCreated datePublished" datetime="2019-09-02T16:29:52+08:00">2019-09-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2019-09-07 19:07:07" itemprop="dateModified" datetime="2019-09-07T19:07:07+08:00">2019-09-07</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="http://mechanitis.blogspot.com/2011/07/dissecting-disruptor-writing-to-ring.html%EF%BC%88%E5%9B%A0%E8%A2%AB%E5%A2%99%E7%A7%BB%E5%88%B0%E5%A2%99%E5%86%85%EF%BC%89">http://mechanitis.blogspot.com/2011/07/dissecting-disruptor-writing-to-ring.html（因被墙移到墙内）</a>  </p>
<p>作者：Trisha</p>
</blockquote>
<p>​    这是disruptor端到端视图中缺失的部分。撑住，这相当长！</p>
<p>要点：</p>
<ul>
<li>无重叠环</li>
<li>通知消费者</li>
<li>批生产</li>
<li>多生产这协作</li>
</ul>
<h4 id="生产者屏障"><a href="#生产者屏障" class="headerlink" title="生产者屏障"></a>生产者屏障</h4><p>​     <code>disruptor </code>源码中有消费者的接口和帮助类，但是没有生产者接口。因为你只需要了解生产者，而不需要额外的访问。像消费端一样， <code>ring buffer</code> 创建了一个生产者屏障，生产者使用 <code>producer   barrier</code> 写入数据到 <code>ring buffer</code>。</p>
<p>​    </p>
<p>​    写入 <code>ring buffer</code> 涉及到两阶段提交。首先，生产者必须申明 <code>ring buffer</code> 中下一个插槽的所有权；之后，当生产者完成对该插槽的写入，它将提交事物到 <code>producer barrier</code> 。</p>
<p>​    我们先看第一步。“给我 <code>ring buffer</code> 的下一个插槽”，这听起来很简单。确实，从生产者角度来看这确实简单。只需要调用 <code>producer barrier</code> 的 <code>nextEntry()</code> 方法，就会给你返回下一个插槽的实体对象。</p>
<h4 id="生产者屏障保证ring-buffer不重叠"><a href="#生产者屏障保证ring-buffer不重叠" class="headerlink" title="生产者屏障保证ring buffer不重叠"></a>生产者屏障保证<code>ring buffer</code>不重叠</h4><p>​    表层之下，<code>producer barrier</code> 确认了下一个插槽是啥，并且你是否有权限写入。</p>
<p><img src="https://private-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/20190902172247.png"></p>
<p>​    在上图中，我们假设只有一个生产者写入 <code>ring buffer</code> 。随后，我们会来处理复杂的多生产者模式。</p>
<p>​    <code>ConsumerTrackingProducerBarrier</code> 持有一系列访问 <code>ring buffer</code> 的消费者。对于我来说，现在看起来有点奇怪。我不想在 <code>producer barrier</code> 关心消费端。不过，这是有原因的。我们不希望队列存在归并关系，我们的消费者有责任知道自己的关心的序列号。所以，如果我们想确认我们没有重叠缓存，我们必须检查消费者的消费位置。</p>
<p>​    上图中，一个消费者恰巧位于最高序列号12；另一个消费者滞后一些，位于序列号3，可能在执行IO等等。因此，消费者2在赶上消费者1之前，需要消费整个缓冲区长度的消息。</p>
<p>​    生产者想向 <code>ring buffer</code> 中当前被序列号3占据位置写入数据，因为这个插槽刚好在 <code>ring buffer</code> 当前指针之后。当时 <code>producer barrier</code> 知道它当前并不能写入，因为有一个消费者正在使用它。然后 <code>producer barrier</code> 只能停下来，自旋，等待该消费者让出插槽。</p>
<h4 id="申明下一个插槽"><a href="#申明下一个插槽" class="headerlink" title="申明下一个插槽"></a>申明下一个插槽</h4><p>​    现在，我们想象一下，消费者2结束那批消息的消费。也许它消费到序列号9的位置（在现实生活中，因为消费者批量消费，往往消费到序列号12的位置。不过，那样的话样例就变得没意思了）</p>
<p><img src="https://private-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/20190906113228.png"></p>
<p>​    上面这张图演示了消费者2更新到序列号9的情形。因为 <code>consumer barrier</code> 在这里没有作用，我省略它。</p>
<p>​    <code>producer barrier</code> 看到下一个插槽变得可用。它窃取了插槽中的实体对象（我还没有专门讨论过这个实体类。简要的说，它基本就是一个筐，存放任何你想放进 <code>ring buffer</code> 的，携带序列号的东西）。设置实体序列号为下一个值（13），然后返回实体到生产者。生产者就能写入任何它想写入的东西。</p>
<h4 id="提交新值"><a href="#提交新值" class="headerlink" title="提交新值"></a>提交新值</h4><p>​    两阶段提交的第二阶段，即是提交。    <img src="https://private-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/20190906181803.png"></p>
<p>​    </p>
<p>​    绿色插槽代表我们刚更新的序列号13的实体。</p>
<p>​    当生产者将消息写入实体，它会通知 <code>producer barrier</code> 去提交。</p>
<p>​    <code>producer barrier</code> 等待 <code>ring buffer</code> 指针捕获我们的位置（在单生产者时，这是毫无意义的。示例：我们知道指针在序列号12位置，没有什么会再写入该序列号。）<code>producer barrier</code> 更新 <code>ring buffer</code> 指针到序列号13。下一步，<code>producer barrier</code> 告诉消费者新消息已经准备好。这依赖于唤醒 <code> consumer barrier</code> 的 <code>wait strategy</code> “醒醒，有事做了”（根据阻塞与否，不同等待策略实现处理方式不同）。</p>
<p>​    现在消费者1可以消费实体13，消费者2可以 消费13及之前实体。他们愉快的工作着。</p>
<h4 id="生产者屏障批处理（并发写入）"><a href="#生产者屏障批处理（并发写入）" class="headerlink" title="生产者屏障批处理（并发写入）"></a>生产者屏障批处理（并发写入）</h4><p>​    有趣的是，<code>disruptor</code> 可以处理多个生产者，就像消费者端一样。回想一下，消费者2什么时候执行程序，并发现自己在位置9的？这里 <code>producer barrier</code> 做了一件狡猾的事 - 它知道缓冲区的长度，知道消费最慢的消费者位置。所以，它能知道哪个插槽可用。</p>
<p><img src="https://private-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/20190907151703.png"></p>
<p>​    假使 <code>producer barrier</code> 知道 <code>ring buffer</code> 的指针在位置12，最慢的消费者在位置9。它就能让生产者写入插槽3，4，5，6，7，8。</p>
<h4 id="多生产者"><a href="#多生产者" class="headerlink" title="多生产者"></a>多生产者</h4><p>​    你是否觉着我已经考虑完了？实际上这里还有更多。</p>
<p>​    上面图中我略有撒谎。我暗示 <code>producer barrier</code> 使用的序列号，直接来源于 <code>ring buffer</code> 的指针。然而，如果查看代码，你会发现它使用 <code>claim strategy</code> 来获取序列号。我跳过这里以简化图形，因为它在单生产者中并不重要。 </p>
<p>​    在多生产者中，你需要另一个组件来跟踪可以写入的序列号。注意，这不是 <code>ring buffer</code> 指针➕1那么简单 - 如果你不仅有一个生产者，有些实体可能正在北写入，且没有被提交。</p>
<p>​    让我们重温申明一个插槽。每一个生产者询问 <code>claim strategy</code> 下一个可用插槽。就像上面单生产者一样，生产者1拿到了序列号13。即使 <code>ring buffer</code> 指针任然指向12，生产者2会拿到序列号14。因为 <code>claim sequence</code> 跟踪已经被分配的序列号。</p>
<p>​    所以，每个生产者拿到它独占的插槽和崭新的序列号。</p>
<p>​    我把生产者1和它的插槽标记为绿色；生产者2和它的插槽标记为可疑的粉色。</p>
<p><img src="https://private-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/20190907181000.png"></p>
<p>​    现在，想象一下生产者1脱离了掌控，处于某种原因未曾提交。生产者2已经准备好提交，询问 <code>producer barrier</code> 是否可以提交。</p>
<p>​    之前提交图中所示，<code>producer barrier</code> 只有当<code>ring buffer</code> 的指针到达想要提交的插槽后方时，它才会提交。在这个案例中，指针抵达13，我们才能提交14。因为生产者1盯着某些闪光的东西没有提交，我们不能提交14。所以 <code>claim strategy</code> 等在那里直到 <code>ring buffer</code> 指针到达指定位置。</p>
<p><img src="https://private-pic-bed.oss-cn-hangzhou.aliyuncs.com/img/20190907182023.png"></p>
<p>​    现在生产者1从昏迷中醒来，提交实例13。<code>producer barrier</code> 告诉 <code>claim stratey</code> <code>ring buffer</code> 指针要在12位置。然后 <code>ring buffer</code> 指针增长到13，<code>producer barrier</code> 通知 <code>wait strategy</code> 让消费者们知道 <code>ring buffer</code> 已经更新。此时，<code>producer barrier</code> 才能结束生产者2的请求，<code>ring buffer</code> 指针增长到14，通知所有消费者我们已经更新。</p>
<p>​    你可以发现，就算生产者结束写入的时间不同，<code>ring buffer</code> 始终保持了初始调用<code>nextEntry()</code> 的顺序。这意味着一旦某个生产者写入时暂停，当它接触锁定后，其他后续提交可以立即执行。</p>
<p>Ps:</p>
<ol>
<li>最新版本中, <code>ring buffer</code> 隐藏了 <code>producer barrier</code> 。如果你找不到，就当它存在于 <code>ring buffer</code>。</li>
<li>2.0版本中，有写类名发生了改变。如果你感到困惑，请参考<a target="_blank" rel="noopener" href="http://mechanitis.blogspot.com/2011/08/disruptor-20-all-change-please.html">my summary of changes</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://stonecj.cn/2019/08/16/false-sharing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shield">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shield‘s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/08/16/false-sharing/" class="post-title-link" itemprop="url">【false sharing】伪共享</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2019-08-16 17:05:38 / Modified: 18:30:32" itemprop="dateCreated datePublished" datetime="2019-08-16T17:05:38+08:00">2019-08-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>当代计算机存储体系，基本构成磁盘、内存、cpu高速缓存、cpu寄存器。</p>
<p>以cpu为例：</p>
<p>​        现代cpu都是多核cpu，cpu一般有3级缓存。其中二级缓存是专用的，多核处理器中，每个内核独享L2 cache；三级缓存则是高层级的缓存，它被所有内核共享。</p>
<h3 id="什么是伪共享"><a href="#什么是伪共享" class="headerlink" title="什么是伪共享"></a>什么是伪共享</h3><p>​        伪共享主要发生在L2 cache。内核独享L2，为了保证不同内核L2数据的一致性，缓存机制会强制刷新已更改的L2。</p>
<p>​        一个数据被修改就会触发L2同步，这很直观，看起来也毫无破绽。不过，考虑到内存块设计，事情就不会这么简单了。内存通常被划分为2的4、8、16等次方KB 或者 MB大小（小批量的读写，可以兼顾吞吐量和实时性）。</p>
<p>​        一旦触发L2同步，那么整个内存块上的数据都会被强制重载。那些即使不曾发生变化的数据，也会被重载。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The two following functions are running concurrently: */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_a</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i)</span><br><span class="line">        s += f.x;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc_b</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i)</span><br><span class="line">        ++f.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(不同内核，同时执行上面方法)</p>
<p>这里x,y会出现在L2同一内存块，x值一直不变，但是由于y发生改变。sum_a必须不断的从主内存加载x。</p>
<p>ps:</p>
<p>java代码中，一般只关注对并发修改字段的处理（加锁）。就算写到这里，我也还没想好怎么应用到自己的代码中去。if you can do, plealse mail to me.  Ths！</p>
<p>ps2:</p>
<p>神奇的解决方法 — 内存块补全。x放入内存后，塞点无用数据，是内存块不能再加载y。</p>
<p>参考：</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://stonecj.cn/2019/07/15/kudu%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shield">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shield‘s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/15/kudu%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">kudu常见问题处理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2019-07-15 18:51:34 / Modified: 19:01:35" itemprop="dateCreated datePublished" datetime="2019-07-15T18:51:34+08:00">2019-07-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="guide-of-kudu"><a href="#guide-of-kudu" class="headerlink" title="guide of kudu"></a>guide of kudu</h2><p>无</p>
<h2 id="impala上操作kudu"><a href="#impala上操作kudu" class="headerlink" title="impala上操作kudu"></a>impala上操作kudu</h2><ol>
<li><p>建表</p>
<ol>
<li><p>```sql<br>CREATE TABLE  dc_stg.kudu_crm_dm_dealer_logs_new (</p>
<pre><code>id  bigint COMMENT &#39;主键id&#39;,
dealer_id  bigint  COMMENT &#39;门店ID&#39;,
account_id  bigint COMMENT &#39;账户ID&#39;,
cuid  bigint COMMENT &#39;创建者&#39;,
opt_info  string COMMENT &#39;信息&#39;,
created  string  COMMENT &#39;创建时间&#39;,
status  int  COMMENT &#39;状态&#39;,
remark  string COMMENT &#39;审核备注/操作记录&#39;,
username  string COMMENT &#39;创建者姓名&#39;,
</code></pre>
<p>  PRIMARY KEY ( id )<br> ) PARTITION BY HASH PARTITIONS 16 COMMENT ‘门店操作日志’<br>STORED AS KUDU;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   2. 特征&#96;STORED AS KUDU&#96;</span><br><span class="line"></span><br><span class="line">2. 删表</span><br><span class="line"></span><br><span class="line">   1. &#96;&#96;&#96;sql</span><br><span class="line">      drop TABLE  dc_stg.kudu_crm_dm_dealer_logs_new;</span><br></pre></td></tr></table></figure></li>
<li><p>此时，impala中关于kudu表的映射关系已删除；但是，kudu表依旧存在</p>
</li>
<li><p>```shell<br>kudu table delete bigdata01:7051,bigdata04:7051 impala::dc_stg.kudu_crm_dm_dealer_logs_new</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   4. ⚠️表名前impala::不可缺失</span><br><span class="line"></span><br><span class="line">3. 数据刷新</span><br><span class="line"></span><br><span class="line">   1. &#96;&#96;&#96;sql</span><br><span class="line">      refresh dc_stg.kudu_crm_dm_dealer_logs_new;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://stonecj.cn/2019/05/16/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shield">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="shield‘s blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/16/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-16 00:13:34" itemprop="dateCreated datePublished" datetime="2019-05-16T00:13:34+08:00">2019-05-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shield</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
